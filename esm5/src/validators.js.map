{"version":3,"file":"validators.js","sourceRoot":"","sources":["../../../../../packages/forms/src/validators.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken, ɵisObservable as isObservable, ɵisPromise as isPromise} from '@angular/core';\nimport {Observable, forkJoin, from} from 'rxjs';\nimport {map} from 'rxjs/operators';\nimport {AsyncValidatorFn, ValidationErrors, Validator, ValidatorFn} from './directives/validators';\nimport {AbstractControl, FormControl} from './model';\n\nfunction isEmptyInputValue(value: any): boolean {\n  // we don't check for string here so it also works with arrays\n  return value == null || value.length === 0;\n}\n\n/**\n * Providers for validators to be used for `FormControl`s in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * ### Example\n *\n * ```typescript\n * @Directive({\n *   selector: '[custom-validator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return {\"custom\": true};\n *   }\n * }\n * ```\n *\n * @stable\n */\nexport const NG_VALIDATORS = new InjectionToken<Array<Validator|Function>>('NgValidators');\n\n/**\n * Providers for asynchronous validators to be used for `FormControl`s\n * in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * See `NG_VALIDATORS` for more details.\n *\n * @stable\n */\nexport const NG_ASYNC_VALIDATORS =\n    new InjectionToken<Array<Validator|Function>>('NgAsyncValidators');\n\nconst EMAIL_REGEXP =\n    /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n\n/**\n * Provides a set of validators used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns a map of errors. A null map means that validation has passed.\n *\n * ### Example\n *\n * ```typescript\n * var loginControl = new FormControl(\"\", Validators.required)\n * ```\n *\n * @stable\n */\nexport class Validators {\n  /**\n   * Validator that requires controls to have a value greater than a number.\n   *`min()` exists only as a function, not as a directive. For example,\n   * `control = new FormControl('', Validators.min(3));`.\n   */\n  static min(min: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value = parseFloat(control.value);\n      // Controls with NaN values after parsing should be treated as not having a\n      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n      return !isNaN(value) && value < min ? {'min': {'min': min, 'actual': control.value}} : null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value less than a number.\n   * `max()` exists only as a function, not as a directive. For example,\n   * `control = new FormControl('', Validators.max(15));`.\n   */\n  static max(max: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value = parseFloat(control.value);\n      // Controls with NaN values after parsing should be treated as not having a\n      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n      return !isNaN(value) && value > max ? {'max': {'max': max, 'actual': control.value}} : null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a non-empty value.\n   */\n  static required(control: AbstractControl): ValidationErrors|null {\n    return isEmptyInputValue(control.value) ? {'required': true} : null;\n  }\n\n  /**\n   * Validator that requires control value to be true.\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    return control.value === true ? null : {'required': true};\n  }\n\n  /**\n   * Validator that performs email validation.\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    if (isEmptyInputValue(control.value)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n  }\n\n  /**\n   * Validator that requires controls to have a value of a minimum length.\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const length: number = control.value ? control.value.length : 0;\n      return length < minLength ?\n          {'minlength': {'requiredLength': minLength, 'actualLength': length}} :\n          null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value of a maximum length.\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      const length: number = control.value ? control.value.length : 0;\n      return length > maxLength ?\n          {'maxlength': {'requiredLength': maxLength, 'actualLength': length}} :\n          null;\n    };\n  }\n\n  /**\n   * Validator that requires a control to match a regex to its value.\n   */\n  static pattern(pattern: string|RegExp): ValidatorFn {\n    if (!pattern) return Validators.nullValidator;\n    let regex: RegExp;\n    let regexStr: string;\n    if (typeof pattern === 'string') {\n      regexStr = '';\n\n      if (pattern.charAt(0) !== '^') regexStr += '^';\n\n      regexStr += pattern;\n\n      if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n\n      regex = new RegExp(regexStr);\n    } else {\n      regexStr = pattern.toString();\n      regex = pattern;\n    }\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value: string = control.value;\n      return regex.test(value) ? null :\n                                 {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n    };\n  }\n\n  /**\n   * No-op validator.\n   */\n  static nullValidator(c: AbstractControl): ValidationErrors|null { return null; }\n\n  /**\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps.\n   */\n  static compose(validators: null): null;\n  static compose(validators: (ValidatorFn|null|undefined)[]): ValidatorFn|null;\n  static compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n    if (!validators) return null;\n    const presentValidators: ValidatorFn[] = validators.filter(isPresent) as any;\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      return _mergeErrors(_executeValidators(control, presentValidators));\n    };\n  }\n\n  static composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n    if (!validators) return null;\n    const presentValidators: AsyncValidatorFn[] = validators.filter(isPresent) as any;\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      const observables = _executeAsyncValidators(control, presentValidators).map(toObservable);\n      return forkJoin(observables).pipe(map(_mergeErrors));\n    };\n  }\n}\n\nfunction isPresent(o: any): boolean {\n  return o != null;\n}\n\nexport function toObservable(r: any): Observable<any> {\n  const obs = isPromise(r) ? from(r) : r;\n  if (!(isObservable(obs))) {\n    throw new Error(`Expected validator to return Promise or Observable.`);\n  }\n  return obs;\n}\n\nfunction _executeValidators(control: AbstractControl, validators: ValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _executeAsyncValidators(control: AbstractControl, validators: AsyncValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _mergeErrors(arrayOfErrors: ValidationErrors[]): ValidationErrors|null {\n  const res: {[key: string]: any} =\n      arrayOfErrors.reduce((res: ValidationErrors | null, errors: ValidationErrors | null) => {\n        return errors != null ? {...res !, ...errors} : res !;\n      }, {});\n  return Object.keys(res).length === 0 ? null : res;\n}\n"]}