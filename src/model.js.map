{"version":3,"sources":["../../../../modules/@angular/forms/src/model.ts"],"names":[],"mappings":"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","file":"model.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {fromPromise} from 'rxjs/observable/fromPromise';\n\nimport {composeAsyncValidators, composeValidators} from './directives/shared';\nimport {AsyncValidatorFn, ValidatorFn} from './directives/validators';\nimport {EventEmitter, Observable} from './facade/async';\nimport {isObservable, isPromise} from './private_import_core';\n\n\n\n/**\n * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.\n */\nexport const /** @type {?} */ VALID = 'VALID';\n\n/**\n * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.\n */\nexport const /** @type {?} */ INVALID = 'INVALID';\n\n/**\n * Indicates that a FormControl is pending, i.e. that async validation is occurring and\n * errors are not yet available for the input value.\n */\nexport const /** @type {?} */ PENDING = 'PENDING';\n\n/**\n * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor\n * calculations of validity or value.\n */\nexport const /** @type {?} */ DISABLED = 'DISABLED';\n/**\n * @param {?} control\n * @param {?} path\n * @param {?} delimiter\n * @return {?}\n */\nfunction _find(control: AbstractControl, path: Array<string|number>| string, delimiter: string) {\n  if (path == null) return null;\n\n  if (!(path instanceof Array)) {\n    path = ( /** @type {?} */((<string>path))).split(delimiter);\n  }\n  if (path instanceof Array && (path.length === 0)) return null;\n\n  return ( /** @type {?} */((<Array<string|number>>path))).reduce((v, name) => {\n    if (v instanceof FormGroup) {\n      return v.controls[name] || null;\n    }\n\n    if (v instanceof FormArray) {\n      return v.at( /** @type {?} */((<number>name))) || null;\n    }\n\n    return null;\n  }, control);\n}\n/**\n * @param {?} r\n * @return {?}\n */\nfunction toObservable(r: any): Observable<any> {\n  return isPromise(r) ? fromPromise(r) : r;\n}\n/**\n * @param {?} validator\n * @return {?}\n */\nfunction coerceToValidator(validator: ValidatorFn | ValidatorFn[]): ValidatorFn {\n  return Array.isArray(validator) ? composeValidators(validator) : validator;\n}\n/**\n * @param {?} asyncValidator\n * @return {?}\n */\nfunction coerceToAsyncValidator(asyncValidator: AsyncValidatorFn | AsyncValidatorFn[]):\n    AsyncValidatorFn {\n  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;\n}\n/**\n * \\@whatItDoes This is the base class for {\\@link FormControl}, {\\@link FormGroup}, and\n * {\\@link FormArray}.\n * \n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n * \n * \\@stable\n * @abstract\n */\nexport abstract class AbstractControl {\n  /** @internal */\n  _value: any;\n  /** @internal */\n  _onCollectionChange = () => {};\nprivate _valueChanges: EventEmitter<any>;\nprivate _statusChanges: EventEmitter<any>;\nprivate _status: string;\nprivate _errors: {[key: string]: any};\nprivate _pristine: boolean = true;\nprivate _touched: boolean = false;\nprivate _parent: FormGroup|FormArray;\nprivate _asyncValidationSubscription: any;\n/**\n * @param {?} validator\n * @param {?} asyncValidator\n */\nconstructor(public validator: ValidatorFn,\npublic asyncValidator: AsyncValidatorFn) {}\n/**\n * The value of the control.\n * @return {?}\n */\nget value(): any { return this._value; }\n/**\n * The parent control.\n * @return {?}\n */\nget parent(): FormGroup|FormArray { return this._parent; }\n/**\n * The validation status of the control. There are four possible\n * validation statuses:\n * \n * * **VALID**:  control has passed all validation checks\n * * **INVALID**: control has failed at least one validation check\n * * **PENDING**: control is in the midst of conducting a validation check\n * * **DISABLED**: control is exempt from validation checks\n * \n * These statuses are mutually exclusive, so a control cannot be\n * both valid AND invalid or invalid AND disabled.\n * @return {?}\n */\nget status(): string { return this._status; }\n/**\n * A control is `valid` when its `status === VALID`.\n * \n * In order to have this status, the control must have passed all its\n * validation checks.\n * @return {?}\n */\nget valid(): boolean { return this._status === VALID; }\n/**\n * A control is `invalid` when its `status === INVALID`.\n * \n * In order to have this status, the control must have failed\n * at least one of its validation checks.\n * @return {?}\n */\nget invalid(): boolean { return this._status === INVALID; }\n/**\n * A control is `pending` when its `status === PENDING`.\n * \n * In order to have this status, the control must be in the\n * middle of conducting a validation check.\n * @return {?}\n */\nget pending(): boolean { return this._status == PENDING; }\n/**\n * A control is `disabled` when its `status === DISABLED`.\n * \n * Disabled controls are exempt from validation checks and\n * are not included in the aggregate value of their ancestor\n * controls.\n * @return {?}\n */\nget disabled(): boolean { return this._status === DISABLED; }\n/**\n * A control is `enabled` as long as its `status !== DISABLED`.\n * \n * In other words, it has a status of `VALID`, `INVALID`, or\n * `PENDING`.\n * @return {?}\n */\nget enabled(): boolean { return this._status !== DISABLED; }\n/**\n * Returns any errors generated by failing validation. If there\n * are no errors, it will return null.\n * @return {?}\n */\nget errors(): {[key: string]: any} { return this._errors; }\n/**\n * A control is `pristine` if the user has not yet changed\n * the value in the UI.\n * \n * Note that programmatic changes to a control's value will\n * *not* mark it dirty.\n * @return {?}\n */\nget pristine(): boolean { return this._pristine; }\n/**\n * A control is `dirty` if the user has changed the value\n * in the UI.\n * \n * Note that programmatic changes to a control's value will\n * *not* mark it dirty.\n * @return {?}\n */\nget dirty(): boolean { return !this.pristine; }\n/**\n * A control is marked `touched` once the user has triggered\n * a `blur` event on it.\n * @return {?}\n */\nget touched(): boolean { return this._touched; }\n/**\n * A control is `untouched` if the user has not yet triggered\n * a `blur` event on it.\n * @return {?}\n */\nget untouched(): boolean { return !this._touched; }\n/**\n * Emits an event every time the value of the control changes, in\n * the UI or programmatically.\n * @return {?}\n */\nget valueChanges(): Observable<any> { return this._valueChanges; }\n/**\n * Emits an event every time the validation status of the control\n * is re-calculated.\n * @return {?}\n */\nget statusChanges(): Observable<any> { return this._statusChanges; }\n/**\n * Sets the synchronous validators that are active on this control.  Calling\n * this will overwrite any existing sync validators.\n * @param {?} newValidator\n * @return {?}\n */\nsetValidators(newValidator: ValidatorFn|ValidatorFn[]): void {\n    this.validator = coerceToValidator(newValidator);\n  }\n/**\n * Sets the async validators that are active on this control. Calling this\n * will overwrite any existing async validators.\n * @param {?} newValidator\n * @return {?}\n */\nsetAsyncValidators(newValidator: AsyncValidatorFn|AsyncValidatorFn[]): void {\n    this.asyncValidator = coerceToAsyncValidator(newValidator);\n  }\n/**\n * Empties out the sync validator list.\n * @return {?}\n */\nclearValidators(): void { this.validator = null; }\n/**\n * Empties out the async validator list.\n * @return {?}\n */\nclearAsyncValidators(): void { this.asyncValidator = null; }\n/**\n * Marks the control as `touched`.\n * \n * This will also mark all direct ancestors as `touched` to maintain\n * the model.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsTouched({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._touched = true;\n\n    if (this._parent && !onlySelf) {\n      this._parent.markAsTouched({onlySelf});\n    }\n  }\n/**\n * Marks the control as `untouched`.\n * \n * If the control has any children, it will also mark all children as `untouched`\n * to maintain the model, and re-calculate the `touched` status of all parent\n * controls.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsUntouched({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._touched = false;\n\n    this._forEachChild(\n        (control: AbstractControl) => { control.markAsUntouched({onlySelf: true}); });\n\n    if (this._parent && !onlySelf) {\n      this._parent._updateTouched({onlySelf});\n    }\n  }\n/**\n * Marks the control as `dirty`.\n * \n * This will also mark all direct ancestors as `dirty` to maintain\n * the model.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsDirty({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._pristine = false;\n\n    if (this._parent && !onlySelf) {\n      this._parent.markAsDirty({onlySelf});\n    }\n  }\n/**\n * Marks the control as `pristine`.\n * \n * If the control has any children, it will also mark all children as `pristine`\n * to maintain the model, and re-calculate the `pristine` status of all parent\n * controls.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsPristine({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._pristine = true;\n\n    this._forEachChild((control: AbstractControl) => { control.markAsPristine({onlySelf: true}); });\n\n    if (this._parent && !onlySelf) {\n      this._parent._updatePristine({onlySelf});\n    }\n  }\n/**\n * Marks the control as `pending`.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsPending({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._status = PENDING;\n\n    if (this._parent && !onlySelf) {\n      this._parent.markAsPending({onlySelf});\n    }\n  }\n/**\n * Disables the control. This means the control will be exempt from validation checks and\n * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n * \n * If the control has children, all children will be disabled to maintain the model.\n * @param {?=} __0\n * @return {?}\n */\ndisable({onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._status = DISABLED;\n    this._errors = null;\n    this._forEachChild((control: AbstractControl) => { control.disable({onlySelf: true}); });\n    this._updateValue();\n\n    if (emitEvent !== false) {\n      this._valueChanges.emit(this._value);\n      this._statusChanges.emit(this._status);\n    }\n\n    this._updateAncestors(onlySelf);\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n/**\n * Enables the control. This means the control will be included in validation checks and\n * the aggregate value of its parent. Its status is re-calculated based on its value and\n * its validators.\n * \n * If the control has children, all children will be enabled.\n * @param {?=} __0\n * @return {?}\n */\nenable({onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._status = VALID;\n    this._forEachChild((control: AbstractControl) => { control.enable({onlySelf: true}); });\n    this.updateValueAndValidity({onlySelf: true, emitEvent});\n\n    this._updateAncestors(onlySelf);\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n/**\n * @param {?} onlySelf\n * @return {?}\n */\nprivate _updateAncestors(onlySelf: boolean) {\n    if (this._parent && !onlySelf) {\n      this._parent.updateValueAndValidity();\n      this._parent._updatePristine();\n      this._parent._updateTouched();\n    }\n  }\n/**\n * @param {?} parent\n * @return {?}\n */\nsetParent(parent: FormGroup|FormArray): void { this._parent = parent; }\n/**\n * Sets the value of the control. Abstract method (implemented in sub-classes).\n * @abstract\n * @param {?} value\n * @param {?=} options\n * @return {?}\n */\nsetValue(value: any, options?: Object) {}\n/**\n * Patches the value of the control. Abstract method (implemented in sub-classes).\n * @abstract\n * @param {?} value\n * @param {?=} options\n * @return {?}\n */\npatchValue(value: any, options?: Object) {}\n/**\n * Resets the control. Abstract method (implemented in sub-classes).\n * @abstract\n * @param {?=} value\n * @param {?=} options\n * @return {?}\n */\nreset(value?: any, options?: Object) {}\n/**\n * Re-calculates the value and validation status of the control.\n * \n * By default, it will also update the value and validity of its ancestors.\n * @param {?=} __0\n * @return {?}\n */\nupdateValueAndValidity({onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._setInitialStatus();\n    this._updateValue();\n\n    if (this.enabled) {\n      this._cancelExistingSubscription();\n      this._errors = this._runValidator();\n      this._status = this._calculateStatus();\n\n      if (this._status === VALID || this._status === PENDING) {\n        this._runAsyncValidator(emitEvent);\n      }\n    }\n\n    if (emitEvent !== false) {\n      this._valueChanges.emit(this._value);\n      this._statusChanges.emit(this._status);\n    }\n\n    if (this._parent && !onlySelf) {\n      this._parent.updateValueAndValidity({onlySelf, emitEvent});\n    }\n  }\n/**\n * \\@internal\n * @param {?=} __0\n * @return {?}\n */\n_updateTreeValidity({emitEvent}: {emitEvent?: boolean} = {emitEvent: true}) {\n    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity({emitEvent}));\n    this.updateValueAndValidity({onlySelf: true, emitEvent});\n  }\n/**\n * @return {?}\n */\nprivate _setInitialStatus() { this._status = this._allControlsDisabled() ? DISABLED : VALID; }\n/**\n * @return {?}\n */\nprivate _runValidator(): {[key: string]: any} {\n    return this.validator ? this.validator(this) : null;\n  }\n/**\n * @param {?} emitEvent\n * @return {?}\n */\nprivate _runAsyncValidator(emitEvent: boolean): void {\n    if (this.asyncValidator) {\n      this._status = PENDING;\n      const /** @type {?} */ obs = toObservable(this.asyncValidator(this));\n      if (!(isObservable(obs))) {\n        throw new Error(\n            `expected the following validator to return Promise or Observable: ${this.asyncValidator}. If you are using FormBuilder; did you forget to brace your validators in an array?`);\n      }\n      this._asyncValidationSubscription =\n          obs.subscribe({next: (res: {[key: string]: any}) => this.setErrors(res, {emitEvent})});\n    }\n  }\n/**\n * @return {?}\n */\nprivate _cancelExistingSubscription(): void {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n    }\n  }\n/**\n * Sets errors on a form control.\n * \n * This is used when validations are run manually by the user, rather than automatically.\n * \n * Calling `setErrors` will also update the validity of the parent control.\n * \n * ### Example\n * \n * ```\n * const login = new FormControl(\"someLogin\");\n * login.setErrors({\n *   \"notUnique\": true\n * });\n * \n * expect(login.valid).toEqual(false);\n * expect(login.errors).toEqual({\"notUnique\": true});\n * \n * login.setValue(\"someOtherLogin\");\n * \n * expect(login.valid).toEqual(true);\n * ```\n * @param {?} errors\n * @param {?=} __1\n * @return {?}\n */\nsetErrors(errors: {[key: string]: any}, {emitEvent}: {emitEvent?: boolean} = {}): void {\n    this._errors = errors;\n    this._updateControlsErrors(emitEvent !== false);\n  }\n/**\n * Retrieves a child control given the control's name or path.\n * \n * Paths can be passed in as an array or a string delimited by a dot.\n * \n * To get a control nested within a `person` sub-group:\n * \n * * `this.form.get('person.name');`\n * \n * -OR-\n * \n * * `this.form.get(['person', 'name']);`\n * @param {?} path\n * @return {?}\n */\nget(path: Array<string|number>|string): AbstractControl { return _find(this, path, '.'); }\n/**\n * Returns true if the control with the given path has the error specified. Otherwise\n * returns null or undefined.\n * \n * If no path is given, it checks for the error on the present control.\n * @param {?} errorCode\n * @param {?=} path\n * @return {?}\n */\ngetError(errorCode: string, path: string[] = null): any {\n    const /** @type {?} */ control = path ? this.get(path) : this;\n    return control && control._errors ? control._errors[errorCode] : null;\n  }\n/**\n * Returns true if the control with the given path has the error specified. Otherwise\n * returns false.\n * \n * If no path is given, it checks for the error on the present control.\n * @param {?} errorCode\n * @param {?=} path\n * @return {?}\n */\nhasError(errorCode: string, path: string[] = null): boolean {\n    return !!this.getError(errorCode, path);\n  }\n/**\n * Retrieves the top-level ancestor of this control.\n * @return {?}\n */\nget root(): AbstractControl {\n    let /** @type {?} */ x: AbstractControl = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n/**\n * \\@internal\n * @param {?} emitEvent\n * @return {?}\n */\n_updateControlsErrors(emitEvent: boolean): void {\n    this._status = this._calculateStatus();\n\n    if (emitEvent) {\n      this._statusChanges.emit(this._status);\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_initObservables() {\n    this._valueChanges = new EventEmitter();\n    this._statusChanges = new EventEmitter();\n  }\n/**\n * @return {?}\n */\nprivate _calculateStatus(): string {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this._errors) return INVALID;\n    if (this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n/**\n * \\@internal\n * @abstract\n * @return {?}\n */\n_updateValue() {}\n/**\n * \\@internal\n * @abstract\n * @param {?} cb\n * @return {?}\n */\n_forEachChild(cb: Function) {}\n/**\n * \\@internal\n * @abstract\n * @param {?} condition\n * @return {?}\n */\n_anyControls(condition: Function) {}\n/**\n * \\@internal\n * @abstract\n * @return {?}\n */\n_allControlsDisabled() {}\n/**\n * \\@internal\n * @param {?} status\n * @return {?}\n */\n_anyControlsHaveStatus(status: string): boolean {\n    return this._anyControls((control: AbstractControl) => control.status === status);\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_anyControlsDirty(): boolean {\n    return this._anyControls((control: AbstractControl) => control.dirty);\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_anyControlsTouched(): boolean {\n    return this._anyControls((control: AbstractControl) => control.touched);\n  }\n/**\n * \\@internal\n * @param {?=} __0\n * @return {?}\n */\n_updatePristine({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._pristine = !this._anyControlsDirty();\n\n    if (this._parent && !onlySelf) {\n      this._parent._updatePristine({onlySelf});\n    }\n  }\n/**\n * \\@internal\n * @param {?=} __0\n * @return {?}\n */\n_updateTouched({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._touched = this._anyControlsTouched();\n\n    if (this._parent && !onlySelf) {\n      this._parent._updateTouched({onlySelf});\n    }\n  }\n\n  /** @internal */\n  _onDisabledChange: Function[] = [];\n/**\n * \\@internal\n * @param {?} formState\n * @return {?}\n */\n_isBoxedValue(formState: any): boolean {\n    return typeof formState === 'object' && formState !== null &&\n        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n  }\n/**\n * \\@internal\n * @param {?} fn\n * @return {?}\n */\n_registerOnCollectionChange(fn: () => void): void { this._onCollectionChange = fn; }\n}\n\nfunction AbstractControl_tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nAbstractControl.prototype._value;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractControl.prototype._onCollectionChange;\n/** @type {?} */\nAbstractControl.prototype._valueChanges;\n/** @type {?} */\nAbstractControl.prototype._statusChanges;\n/** @type {?} */\nAbstractControl.prototype._status;\n/** @type {?} */\nAbstractControl.prototype._errors;\n/** @type {?} */\nAbstractControl.prototype._pristine;\n/** @type {?} */\nAbstractControl.prototype._touched;\n/** @type {?} */\nAbstractControl.prototype._parent;\n/** @type {?} */\nAbstractControl.prototype._asyncValidationSubscription;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractControl.prototype._onDisabledChange;\n/** @type {?} */\nAbstractControl.prototype.validator;\n/** @type {?} */\nAbstractControl.prototype.asyncValidator;\n}\n\n/**\n * \\@whatItDoes Tracks the value and validation status of an individual form control.\n * \n * It is one of the three fundamental building blocks of Angular forms, along with\n * {\\@link FormGroup} and {\\@link FormArray}.\n * \n * \\@howToUse \n * \n * When instantiating a {\\@link FormControl}, you can pass in an initial value as the\n * first argument. Example:\n * \n * ```ts\n * const ctrl = new FormControl('some value');\n * console.log(ctrl.value);     // 'some value'\n * ```\n * \n * You can also initialize the control with a form state object on instantiation,\n * which includes both the value and whether or not the control is disabled.\n * You can't use the value key without the disabled key; both are required\n * to use this way of initialization.\n * \n * ```ts\n * const ctrl = new FormControl({value: 'n/a', disabled: true});\n * console.log(ctrl.value);     // 'n/a'\n * console.log(ctrl.status);   // 'DISABLED'\n * ```\n * \n * To include a sync validator (or an array of sync validators) with the control,\n * pass it in as the second argument. Async validators are also supported, but\n * have to be passed in separately as the third arg.\n * \n * ```ts\n * const ctrl = new FormControl('', Validators.required);\n * console.log(ctrl.value);     // ''\n * console.log(ctrl.status);   // 'INVALID'\n * ```\n * \n * See its superclass, {\\@link AbstractControl}, for more properties and methods.\n * \n * * **npm package**: `\\@angular/forms`\n * \n * \\@stable\n */\nexport class FormControl extends AbstractControl {\n  /** @internal */\n  _onChange: Function[] = [];\n/**\n * @param {?=} formState\n * @param {?=} validator\n * @param {?=} asyncValidator\n */\nconstructor(\n      formState: any = null, validator: ValidatorFn|ValidatorFn[] = null,\n      asyncValidator: AsyncValidatorFn|AsyncValidatorFn[] = null) {\n    super(coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));\n    this._applyFormState(formState);\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n    this._initObservables();\n  }\n/**\n * Set the value of the form control to `value`.\n * \n * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`\n * and not its parent component. This defaults to false.\n * \n * If `emitEvent` is `true`, this\n * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults\n * to true (as it falls through to `updateValueAndValidity`).\n * \n * If `emitModelToViewChange` is `true`, the view will be notified about the new value\n * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not\n * specified.\n * \n * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the\n * model.  This is the default behavior if `emitViewToModelChange` is not specified.\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\nsetValue(value: any, {onlySelf, emitEvent, emitModelToViewChange, emitViewToModelChange}: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    this._value = value;\n    if (this._onChange.length && emitModelToViewChange !== false) {\n      this._onChange.forEach((changeFn) => changeFn(this._value, emitViewToModelChange !== false));\n    }\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n * Patches the value of a control.\n * \n * This function is functionally the same as {\\@link FormControl.setValue} at this level.\n * It exists for symmetry with {\\@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,\n * where it does behave differently.\n * @param {?} value\n * @param {?=} options\n * @return {?}\n */\npatchValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    this.setValue(value, options);\n  }\n/**\n * Resets the form control. This means by default:\n * \n * * it is marked as `pristine`\n * * it is marked as `untouched`\n * * value is set to null\n * \n * You can also reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n * \n * Ex:\n * \n * ```ts\n * this.control.reset('Nancy');\n * \n * console.log(this.control.value);  // 'Nancy'\n * ```\n * \n * OR\n * \n * ```\n * this.control.reset({value: 'Nancy', disabled: true});\n * \n * console.log(this.control.value);  // 'Nancy'\n * console.log(this.control.status);  // 'DISABLED'\n * ```\n * @param {?=} formState\n * @param {?=} __1\n * @return {?}\n */\nreset(formState: any = null, {onlySelf, emitEvent}: {onlySelf?: boolean,\n                                                       emitEvent?: boolean} = {}): void {\n    this._applyFormState(formState);\n    this.markAsPristine({onlySelf});\n    this.markAsUntouched({onlySelf});\n    this.setValue(this._value, {onlySelf, emitEvent});\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_updateValue() {}\n/**\n * \\@internal\n * @param {?} condition\n * @return {?}\n */\n_anyControls(condition: Function): boolean { return false; }\n/**\n * \\@internal\n * @return {?}\n */\n_allControlsDisabled(): boolean { return this.disabled; }\n/**\n * Register a listener for change events.\n * @param {?} fn\n * @return {?}\n */\nregisterOnChange(fn: Function): void { this._onChange.push(fn); }\n/**\n * \\@internal\n * @return {?}\n */\n_clearChangeFns(): void {\n    this._onChange = [];\n    this._onDisabledChange = [];\n    this._onCollectionChange = () => {};\n  }\n/**\n * Register a listener for disabled events.\n * @param {?} fn\n * @return {?}\n */\nregisterOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    this._onDisabledChange.push(fn);\n  }\n/**\n * \\@internal\n * @param {?} cb\n * @return {?}\n */\n_forEachChild(cb: Function): void {}\n/**\n * @param {?} formState\n * @return {?}\n */\nprivate _applyFormState(formState: any) {\n    if (this._isBoxedValue(formState)) {\n      this._value = formState.value;\n      formState.disabled ? this.disable({onlySelf: true, emitEvent: false}) :\n                           this.enable({onlySelf: true, emitEvent: false});\n    } else {\n      this._value = formState;\n    }\n  }\n}\n\nfunction FormControl_tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nFormControl.prototype._onChange;\n}\n\n/**\n * \\@whatItDoes Tracks the value and validity state of a group of {\\@link FormControl}\n * instances.\n * \n * A `FormGroup` aggregates the values of each child {\\@link FormControl} into one object,\n * with each control name as the key.  It calculates its status by reducing the statuses\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n * \n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with {\\@link FormControl} and {\\@link FormArray}.\n * \n * \\@howToUse \n * \n * When instantiating a {\\@link FormGroup}, pass in a collection of child controls as the first\n * argument. The key for each child will be the name under which it is registered.\n * \n * ### Example\n * \n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n * \n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n * \n * You can also include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n * \n * ### Example\n * \n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n * \n * \n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n * \n * * **npm package**: `\\@angular/forms`\n * \n * \\@stable\n */\nexport class FormGroup extends AbstractControl {\n/**\n * @param {?} controls\n * @param {?=} validator\n * @param {?=} asyncValidator\n */\nconstructor(\npublic controls: {[key: string]: AbstractControl}, validator: ValidatorFn = null,\n      asyncValidator: AsyncValidatorFn = null) {\n    super(validator, asyncValidator);\n    this._initObservables();\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n/**\n * Registers a control with the group's list of controls.\n * \n * This method does not update value or validity of the control, so for\n * most cases you'll want to use {\\@link FormGroup.addControl} instead.\n * @param {?} name\n * @param {?} control\n * @return {?}\n */\nregisterControl(name: string, control: AbstractControl): AbstractControl {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n/**\n * Add a control to this group.\n * @param {?} name\n * @param {?} control\n * @return {?}\n */\naddControl(name: string, control: AbstractControl): void {\n    this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Remove a control from this group.\n * @param {?} name\n * @return {?}\n */\nremoveControl(name: string): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Replace an existing control.\n * @param {?} name\n * @param {?} control\n * @return {?}\n */\nsetControl(name: string, control: AbstractControl): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Check whether there is an enabled control with the given name in the group.\n * \n * It will return false for disabled controls. If you'd like to check for\n * existence in the group only, use {\\@link AbstractControl.get} instead.\n * @param {?} controlName\n * @return {?}\n */\ncontains(controlName: string): boolean {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n/**\n *  Sets the value of the {\\@link FormGroup}. It accepts an object that matches\n *  the structure of the group, with control names as keys.\n * \n * This method performs strict checks, so it will throw an error if you try\n * to set the value of a control that doesn't exist or if you exclude the\n * value of a control.\n * \n *  ### Example\n * \n *  ```\n *  const form = new FormGroup({\n *     first: new FormControl(),\n *     last: new FormControl()\n *  });\n *  console.log(form.value);   // {first: null, last: null}\n * \n *  form.setValue({first: 'Nancy', last: 'Drew'});\n *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n * \n *  ```\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\nsetValue(\n      value: {[key: string]: any},\n      {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._checkAllValuesPresent(value);\n    Object.keys(value).forEach(name => {\n      this._throwIfControlMissing(name);\n      this.controls[name].setValue(value[name], {onlySelf: true, emitEvent});\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n *  Patches the value of the {\\@link FormGroup}. It accepts an object with control\n *  names as keys, and will do its best to match the values to the correct controls\n *  in the group.\n * \n *  It accepts both super-sets and sub-sets of the group without throwing an error.\n * \n *  ### Example\n * \n *  ```\n *  const form = new FormGroup({\n *     first: new FormControl(),\n *     last: new FormControl()\n *  });\n *  console.log(form.value);   // {first: null, last: null}\n * \n *  form.patchValue({first: 'Nancy'});\n *  console.log(form.value);   // {first: 'Nancy', last: null}\n * \n *  ```\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\npatchValue(\n      value: {[key: string]: any},\n      {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    Object.keys(value).forEach(name => {\n      if (this.controls[name]) {\n        this.controls[name].patchValue(value[name], {onlySelf: true, emitEvent});\n      }\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n * Resets the {\\@link FormGroup}. This means by default:\n * \n * * The group and all descendants are marked `pristine`\n * * The group and all descendants are marked `untouched`\n * * The value of all descendants will be null or null maps\n * \n * You can also reset to a specific form state by passing in a map of states\n * that matches the structure of your form, with control names as keys. The state\n * can be a standalone value or a form state object with both a value and a disabled\n * status.\n * \n * ### Example\n * \n * ```ts\n * this.form.reset({first: 'name', last: 'last name'});\n * \n * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n * ```\n * \n * - OR -\n * \n * ```\n * this.form.reset({\n *   first: {value: 'name', disabled: true},\n *   last: 'last'\n * });\n * \n * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n * console.log(this.form.get('first').status);  // 'DISABLED'\n * ```\n * @param {?=} value\n * @param {?=} __1\n * @return {?}\n */\nreset(value: any = {}, {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      control.reset(value[name], {onlySelf: true, emitEvent});\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n    this._updatePristine({onlySelf});\n    this._updateTouched({onlySelf});\n  }\n/**\n * The aggregate value of the {\\@link FormGroup}, including any disabled controls.\n * \n * If you'd like to include all values regardless of disabled status, use this method.\n * Otherwise, the `value` property is the best way to get the value of the group.\n * @return {?}\n */\ngetRawValue(): any {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          acc[name] = control instanceof FormControl ? control.value : ( /** @type {?} */((<any>control))).getRawValue();\n          return acc;\n        });\n  }\n/**\n * \\@internal\n * @param {?} name\n * @return {?}\n */\n_throwIfControlMissing(name: string): void {\n    if (!Object.keys(this.controls).length) {\n      throw new Error(`\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.controls[name]) {\n      throw new Error(`Cannot find form control with name: ${name}.`);\n    }\n  }\n/**\n * \\@internal\n * @param {?} cb\n * @return {?}\n */\n_forEachChild(cb: (v: any, k: string) => void): void {\n    Object.keys(this.controls).forEach(k => cb(this.controls[k], k));\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_updateValue(): void { this._value = this._reduceValue(); }\n/**\n * \\@internal\n * @param {?} condition\n * @return {?}\n */\n_anyControls(condition: Function): boolean {\n    let /** @type {?} */ res = false;\n    this._forEachChild((control: AbstractControl, name: string) => {\n      res = res || (this.contains(name) && condition(control));\n    });\n    return res;\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_reduceValue() {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          if (control.enabled || this.disabled) {\n            acc[name] = control.value;\n          }\n          return acc;\n        });\n  }\n/**\n * \\@internal\n * @param {?} initValue\n * @param {?} fn\n * @return {?}\n */\n_reduceChildren(initValue: any, fn: Function) {\n    let /** @type {?} */ res = initValue;\n    this._forEachChild(\n        (control: AbstractControl, name: string) => { res = fn(res, control, name); });\n    return res;\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_allControlsDisabled(): boolean {\n    for (const /** @type {?} */ controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n/**\n * \\@internal\n * @param {?} value\n * @return {?}\n */\n_checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      if (value[name] === undefined) {\n        throw new Error(`Must supply a value for form control with name: '${name}'.`);\n      }\n    });\n  }\n}\n\nfunction FormGroup_tsickle_Closure_declarations() {\n/** @type {?} */\nFormGroup.prototype.controls;\n}\n\n/**\n * \\@whatItDoes Tracks the value and validity state of an array of {\\@link FormControl},\n * {\\@link FormGroup} or {\\@link FormArray} instances.\n * \n * A `FormArray` aggregates the values of each child {\\@link FormControl} into an array.\n * It calculates its status by reducing the statuses of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n * \n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with {\\@link FormControl} and {\\@link FormGroup}.\n * \n * \\@howToUse \n * \n * When instantiating a {\\@link FormArray}, pass in an array of child controls as the first\n * argument.\n * \n * ### Example\n * \n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n * \n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n * \n * You can also include array-level validators as the second arg, or array-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n * \n * ### Adding or removing controls\n * \n * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that will result in strange and unexpected behavior such\n * as broken change detection.\n * \n * * **npm package**: `\\@angular/forms`\n * \n * \\@stable\n */\nexport class FormArray extends AbstractControl {\n/**\n * @param {?} controls\n * @param {?=} validator\n * @param {?=} asyncValidator\n */\nconstructor(\npublic controls: AbstractControl[], validator: ValidatorFn = null,\n      asyncValidator: AsyncValidatorFn = null) {\n    super(validator, asyncValidator);\n    this._initObservables();\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n/**\n * Get the {\\@link AbstractControl} at the given `index` in the array.\n * @param {?} index\n * @return {?}\n */\nat(index: number): AbstractControl { return this.controls[index]; }\n/**\n * Insert a new {\\@link AbstractControl} at the end of the array.\n * @param {?} control\n * @return {?}\n */\npush(control: AbstractControl): void {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Insert a new {\\@link AbstractControl} at the given `index` in the array.\n * @param {?} index\n * @param {?} control\n * @return {?}\n */\ninsert(index: number, control: AbstractControl): void {\n    this.controls.splice(index, 0, control);\n\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Remove the control at the given `index` in the array.\n * @param {?} index\n * @return {?}\n */\nremoveAt(index: number): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Replace an existing control.\n * @param {?} index\n * @param {?} control\n * @return {?}\n */\nsetControl(index: number, control: AbstractControl): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n\n    if (control) {\n      this.controls.splice(index, 0, control);\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Length of the control array.\n * @return {?}\n */\nget length(): number { return this.controls.length; }\n/**\n *  Sets the value of the {\\@link FormArray}. It accepts an array that matches\n *  the structure of the control.\n * \n * This method performs strict checks, so it will throw an error if you try\n * to set the value of a control that doesn't exist or if you exclude the\n * value of a control.\n * \n *  ### Example\n * \n *  ```\n *  const arr = new FormArray([\n *     new FormControl(),\n *     new FormControl()\n *  ]);\n *  console.log(arr.value);   // [null, null]\n * \n *  arr.setValue(['Nancy', 'Drew']);\n *  console.log(arr.value);   // ['Nancy', 'Drew']\n *  ```\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\nsetValue(value: any[], {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._checkAllValuesPresent(value);\n    value.forEach((newValue: any, index: number) => {\n      this._throwIfControlMissing(index);\n      this.at(index).setValue(newValue, {onlySelf: true, emitEvent});\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n *  Patches the value of the {\\@link FormArray}. It accepts an array that matches the\n *  structure of the control, and will do its best to match the values to the correct\n *  controls in the group.\n * \n *  It accepts both super-sets and sub-sets of the array without throwing an error.\n * \n *  ### Example\n * \n *  ```\n *  const arr = new FormArray([\n *     new FormControl(),\n *     new FormControl()\n *  ]);\n *  console.log(arr.value);   // [null, null]\n * \n *  arr.patchValue(['Nancy']);\n *  console.log(arr.value);   // ['Nancy', null]\n *  ```\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\npatchValue(value: any[], {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    value.forEach((newValue: any, index: number) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {onlySelf: true, emitEvent});\n      }\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n * Resets the {\\@link FormArray}. This means by default:\n * \n * * The array and all descendants are marked `pristine`\n * * The array and all descendants are marked `untouched`\n * * The value of all descendants will be null or null maps\n * \n * You can also reset to a specific form state by passing in an array of states\n * that matches the structure of the control. The state can be a standalone value\n * or a form state object with both a value and a disabled status.\n * \n * ### Example\n * \n * ```ts\n * this.arr.reset(['name', 'last name']);\n * \n * console.log(this.arr.value);  // ['name', 'last name']\n * ```\n * \n * - OR -\n * \n * ```\n * this.arr.reset([\n *   {value: 'name', disabled: true},\n *   'last'\n * ]);\n * \n * console.log(this.arr.value);  // ['name', 'last name']\n * console.log(this.arr.get(0).status);  // 'DISABLED'\n * ```\n * @param {?=} value\n * @param {?=} __1\n * @return {?}\n */\nreset(value: any = [], {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._forEachChild((control: AbstractControl, index: number) => {\n      control.reset(value[index], {onlySelf: true, emitEvent});\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n    this._updatePristine({onlySelf});\n    this._updateTouched({onlySelf});\n  }\n/**\n * The aggregate value of the array, including any disabled controls.\n * \n * If you'd like to include all values regardless of disabled status, use this method.\n * Otherwise, the `value` property is the best way to get the value of the array.\n * @return {?}\n */\ngetRawValue(): any[] {\n    return this.controls.map((control: AbstractControl) => {\n      return control instanceof FormControl ? control.value : ( /** @type {?} */((<any>control))).getRawValue();\n    });\n  }\n/**\n * \\@internal\n * @param {?} index\n * @return {?}\n */\n_throwIfControlMissing(index: number): void {\n    if (!this.controls.length) {\n      throw new Error(`\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.at(index)) {\n      throw new Error(`Cannot find form control at index ${index}`);\n    }\n  }\n/**\n * \\@internal\n * @param {?} cb\n * @return {?}\n */\n_forEachChild(cb: Function): void {\n    this.controls.forEach((control: AbstractControl, index: number) => { cb(control, index); });\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_updateValue(): void {\n    this._value = this.controls.filter((control) => control.enabled || this.disabled)\n                      .map((control) => control.value);\n  }\n/**\n * \\@internal\n * @param {?} condition\n * @return {?}\n */\n_anyControls(condition: Function): boolean {\n    return this.controls.some((control: AbstractControl) => control.enabled && condition(control));\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => this._registerControl(control));\n  }\n/**\n * \\@internal\n * @param {?} value\n * @return {?}\n */\n_checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, i: number) => {\n      if (value[i] === undefined) {\n        throw new Error(`Must supply a value for form control at index: ${i}.`);\n      }\n    });\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_allControlsDisabled(): boolean {\n    for (const /** @type {?} */ control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n/**\n * @param {?} control\n * @return {?}\n */\nprivate _registerControl(control: AbstractControl) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n}\n\nfunction FormArray_tsickle_Closure_declarations() {\n/** @type {?} */\nFormArray.prototype.controls;\n}\n\n"]}