{"version":3,"sources":["../../../../modules/@angular/forms/src/validators.ts"],"names":[],"mappings":"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","file":"validators.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core/index';\nimport {toPromise} from 'rxjs/operator/toPromise';\n\nimport {AsyncValidatorFn, Validator, ValidatorFn} from './directives/validators';\nimport {StringMapWrapper} from './facade/collection';\nimport {isPresent} from './facade/lang';\nimport {AbstractControl, FormControl, FormGroup} from './model';\nimport {isPromise} from './private_import_core';\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isEmptyInputValue(value: any): boolean {\n  // we don't check for string here so it also works with arrays\n  return value == null || value.length === 0;\n}\n\n/**\n * Providers for validators to be used for {@link FormControl}s in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * ### Example\n *\n * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}\n * @stable\n */\nexport const /** @type {?} */ NG_VALIDATORS = new InjectionToken<Array<Validator|Function>>('NgValidators');\n\n/**\n * Providers for asynchronous validators to be used for {@link FormControl}s\n * in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * See {@link NG_VALIDATORS} for more details.\n *\n * @stable\n */\nexport const /** @type {?} */ NG_ASYNC_VALIDATORS =\n    new InjectionToken<Array<Validator|Function>>('NgAsyncValidators');\n\nconst /** @type {?} */ EMAIL_REGEXP =\n    /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n/**\n * Provides a set of validators used by form controls.\n * \n * A validator is a function that processes a {\\@link FormControl} or collection of\n * controls and returns a map of errors. A null map means that validation has passed.\n * \n * ### Example\n * \n * ```typescript\n * var loginControl = new FormControl(\"\", Validators.required)\n * ```\n * \n * \\@stable\n */\nexport class Validators {\n/**\n * Validator that compares the value of the given FormControls\n * @param {...?} fieldPaths\n * @return {?}\n */\nstatic equalsTo(...fieldPaths: string[]): ValidatorFn {\n    return function(control: FormControl): {[key: string]: any} {\n      if (fieldPaths.length < 1) {\n        throw new Error('You must compare to at least 1 other field');\n      }\n\n      for (let /** @type {?} */ fieldName of fieldPaths) {\n        let /** @type {?} */ field = ( /** @type {?} */((<FormGroup>control.parent))).get(fieldName);\n        if (!field) {\n          throw new Error(\n              `Field: ${fieldName} undefined, are you sure that ${fieldName} exists in the group`);\n        }\n\n        if (field.value !== control.value) {\n          return {'equalsTo': {'unequalField': fieldName}};\n        }\n      }\n      return null;\n    };\n  }\n/**\n * Validator that requires controls to have a non-empty value.\n * @param {?} control\n * @return {?}\n */\nstatic required(control: AbstractControl): {[key: string]: boolean} {\n    return isEmptyInputValue(control.value) ? {'required': true} : null;\n  }\n/**\n * Validator that requires control value to be true.\n * @param {?} control\n * @return {?}\n */\nstatic requiredTrue(control: AbstractControl): {[key: string]: boolean} {\n    return control.value === true ? null : {'required': true};\n  }\n/**\n * Validator that performs email validation.\n * @param {?} control\n * @return {?}\n */\nstatic email(control: AbstractControl): {[key: string]: boolean} {\n    return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n  }\n/**\n * Validator that requires controls to have a value of a minimum length.\n * @param {?} minLength\n * @return {?}\n */\nstatic minLength(minLength: number): ValidatorFn {\n    return (control: AbstractControl): {[key: string]: any} => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const /** @type {?} */ length: number = control.value ? control.value.length : 0;\n      return length < minLength ?\n          {'minlength': {'requiredLength': minLength, 'actualLength': length}} :\n          null;\n    };\n  }\n/**\n * Validator that requires controls to have a value of a maximum length.\n * @param {?} maxLength\n * @return {?}\n */\nstatic maxLength(maxLength: number): ValidatorFn {\n    return (control: AbstractControl): {[key: string]: any} => {\n      const /** @type {?} */ length: number = control.value ? control.value.length : 0;\n      return length > maxLength ?\n          {'maxlength': {'requiredLength': maxLength, 'actualLength': length}} :\n          null;\n    };\n  }\n/**\n * Validator that requires a control to match a regex to its value.\n * @param {?} pattern\n * @return {?}\n */\nstatic pattern(pattern: string|RegExp): ValidatorFn {\n    if (!pattern) return Validators.nullValidator;\n    let /** @type {?} */ regex: RegExp;\n    let /** @type {?} */ regexStr: string;\n    if (typeof pattern === 'string') {\n      regexStr = `^${pattern}$`;\n      regex = new RegExp(regexStr);\n    } else {\n      regexStr = pattern.toString();\n      regex = pattern;\n    }\n    return (control: AbstractControl): {[key: string]: any} => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const /** @type {?} */ value: string = control.value;\n      return regex.test(value) ? null :\n                                 {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n    };\n  }\n/**\n * No-op validator.\n * @param {?} c\n * @return {?}\n */\nstatic nullValidator(c: AbstractControl): {[key: string]: boolean} { return null; }\n/**\n * Compose multiple validators into a single function that returns the union\n * of the individual error maps.\n * @param {?} validators\n * @return {?}\n */\nstatic compose(validators: ValidatorFn[]): ValidatorFn {\n    if (!validators) return null;\n    const /** @type {?} */ presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      return _mergeErrors(_executeValidators(control, presentValidators));\n    };\n  }\n/**\n * @param {?} validators\n * @return {?}\n */\nstatic composeAsync(validators: AsyncValidatorFn[]): AsyncValidatorFn {\n    if (!validators) return null;\n    const /** @type {?} */ presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      const /** @type {?} */ promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);\n      return Promise.all(promises).then(_mergeErrors);\n    };\n  }\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _convertToPromise(obj: any): Promise<any> {\n  return isPromise(obj) ? obj : toPromise.call(obj);\n}\n/**\n * @param {?} control\n * @param {?} validators\n * @return {?}\n */\nfunction _executeValidators(control: AbstractControl, validators: ValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n/**\n * @param {?} control\n * @param {?} validators\n * @return {?}\n */\nfunction _executeAsyncValidators(control: AbstractControl, validators: AsyncValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n/**\n * @param {?} arrayOfErrors\n * @return {?}\n */\nfunction _mergeErrors(arrayOfErrors: any[]): {[key: string]: any} {\n  const /** @type {?} */ res: {[key: string]: any} =\n      arrayOfErrors.reduce((res: {[key: string]: any}, errors: {[key: string]: any}) => {\n        return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;\n      }, {});\n  return Object.keys(res).length === 0 ? null : res;\n}\n"]}